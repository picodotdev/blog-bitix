<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">Blog Bitix</title>
    <subtitle type="text">Blog sobre el lenguaje de programación Java y la distribución GNU/Linux que uso habitualmente, Arch Linux, lo que aprendo sobre el software libre, la programación web y otros temas relacionados con la tecnología y la informática. El contenido puede contener trazas de asuntos fuera de tema.</subtitle>
    <link rel="self" href="https://picodotdev.github.io/blog-bitix/index.xml"/>
    <link href="https://picodotdev.github.io/blog-bitix/" />
    <id>https://picodotdev.github.io/blog-bitix/tags/java/</id>
    <updated>2023-03-16T20:30:00+02:00</updated>
    <author><name>picodotdev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix/assets/favicon.ico</icon>
    <logo>https://picodotdev.github.io/blog-bitix/assets/images/blog-bitix.svg</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/07/servidor-mock-para-imitar-peticiones-y-respuestas-de-servicios-http-con-wiremock/</id>
        <title>Servidor mock para imitar peticiones y respuestas de servicios HTTP con WireMock</title>
        <updated>2021-07-30T12:00:00+02:00</updated>
        <published>2021-07-30T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/07/servidor-mock-para-imitar-peticiones-y-respuestas-de-servicios-http-con-wiremock/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Los microservicios aportan varias ventajas pero también algunos inconvenientes que si no son manejados generan sus propios problemas. Una dificultad de los servicios por las dependencias entre ellos es poder desarrollarlos y probarlos en local, algunos microservicios son complejos con dependencia sobre bases de datos, sistemas de envío de mensajes u otros servicios. Si un microservicio necesita iniciar en local o en entorno todas sus dependencias el desarrollo se vuelve complejo y lento. Para facilitar el desarrollo una opción es utilizar un servidor <em>mock</em> que imite las respuestas para las peticiones que se necesite de uno o varios servicios.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/07/servidor-mock-para-imitar-peticiones-y-respuestas-de-servicios-http-con-wiremock/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/07/formas-de-generar-un-numero-aleatorio-en-un-rango-con-java/</id>
        <title>Formas de generar un número aleatorio en un rango con Java</title>
        <updated>2021-07-22T19:30:00+02:00</updated>
        <published>2021-07-22T19:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/07/formas-de-generar-un-numero-aleatorio-en-un-rango-con-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>En Java hay varias formas de generar números aleatorios, la clase <em>Random</em> permite generar números aleatorios individuales y desde Java 8 con la adición de <em>streams</em> permite obtener una secuencia de números aleatorios de tamaño determinado o indefinido. La clase <em>Math</em> también permite generar números aleatorios aunque es más recomendable usar la clase <em>Random</em>. Finalmente, en caso de querer un identificativo único universal está la clase UUID que genera números aleatorios de 128 bits que se representan mediante caracteres alfanuméricos.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/07/formas-de-generar-un-numero-aleatorio-en-un-rango-con-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/07/los-niveles-de-madurez-rest-ejemplo-con-hateoas-y-documentacion-con-swagger-de-un-servicio-con-spring-boot/</id>
        <title>Los niveles de madurez REST, ejemplo con HATEOAS y documentación con Swagger de un servicio con Spring Boot</title>
        <updated>2021-07-15T19:00:00+02:00</updated>
        <published>2021-07-15T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/07/los-niveles-de-madurez-rest-ejemplo-con-hateoas-y-documentacion-con-swagger-de-un-servicio-con-spring-boot/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Los niveles de madurez de una API implementada con las convenciones REST trata de aplicar los conceptos y semántica de la web y el protocolo HTTP a un servicio web. Muchas APIs que dicen ser REST no cumplen con todos los niveles de madurez para ser considerada RESTful que incluyen HATEOAS para crear enlaces entre los recursos y HAL para codificar los datos. Muchas se quedan en el nivel 2 al hacer uso únicamente de recursos y verbos, llegar a cumplir el nivel 3 para incluir controles <em>hypermedia</em> tiene algunas ventajas adicionales. Spring Boot proporciona soporte para crear una API que soporte el nivel de madurez 3 de REST y Springdoc permite generar la documentación de la API con Swagger.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/07/los-niveles-de-madurez-rest-ejemplo-con-hateoas-y-documentacion-con-swagger-de-un-servicio-con-spring-boot/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/07/como-documentar-una-api-rest-con-swagger-implementada-con-spring-boot/</id>
        <title>Cómo documentar una API REST con Swagger implementada con Spring Boot</title>
        <updated>2021-07-12T22:00:00+02:00</updated>
        <published>2021-07-01T20:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/07/como-documentar-una-api-rest-con-swagger-implementada-con-spring-boot/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Una API REST no está obligada a publicar una definición de su API, sin embargo, para quien deba usar API es muy útil disponer de su documentación para usarla correctamente y descubrir de qué <em>endpoints</em> se compone, métodos HTTP, cuales son sus parámetros, el esquema de los cuerpos de la petición y de los resultados, los tipos de los datos y sus formatos, los códigos de retorno devueltos, las cabeceras y su autenticación. OpenAPI permite definir la interfaz de una aplicación de forma agnóstica de la tecnología y lenguaje en el que se implementa, por otro lado Swagger a partir de esa definición permite generar una interfaz HTML con su documentación. La librería Springdoc junto con Spring Boot permite generar tanto la especificación de la API como la documentación simplemente añadiendo una dependencia y varias anotaciones en la implementación de la API.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/07/como-documentar-una-api-rest-con-swagger-implementada-con-spring-boot/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/06/los-automatas-del-juego-de-la-vida-de-conway-y-la-hormiga-langton-con-su-implementacion-en-java/</id>
        <title>Los autómatas del juego de la vida de Conway y la hormiga Langton con su implementación en Java</title>
        <updated>2021-06-18T23:00:00+02:00</updated>
        <published>2021-06-18T23:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/06/los-automatas-del-juego-de-la-vida-de-conway-y-la-hormiga-langton-con-su-implementacion-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Algunos procesos que aparentemente son complejos siguen reglas muy simples, y aún siguiendo reglas muy simples dan lugar a muchos posibles comportamientos diferentes. Los sistemas que implementan y aplican estas reglas simples se les conoce como autómatas. Los autómatas no poseen inteligencia artificial, no aprenden ni toman decisiones en base a anteriores resultados, los autómatas simplemente siguen sus reglas de comportamiento en el estado del sistema. Dos autómatas conocidos son el juego de la vida de <a href="https://es.wikipedia.org/wiki/John_Horton_Conway">John Horton Conway</a> publicado en 1970 y la hormiga de Langton de <a href="https://es.wikipedia.org/wiki/Christopher_Langton">Chris Langton</a> publicado en 1986.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/06/los-automatas-del-juego-de-la-vida-de-conway-y-la-hormiga-langton-con-su-implementacion-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/06/implementacion-de-los-algoritmos-de-ordenacion-bubble-sort-merge-sort-y-quicksort-en-java/</id>
        <title>Implementación de los algoritmos de ordenación bubble sort, merge sort y quicksort en Java</title>
        <updated>2021-06-03T19:30:00+02:00</updated>
        <published>2021-06-03T19:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/06/implementacion-de-los-algoritmos-de-ordenacion-bubble-sort-merge-sort-y-quicksort-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Hay una buena cantidad de algoritmos de ordenación conocidos, entre los más conocidos está el <em>bubble sort</em>, el <em>merge sort</em> y el <em>quicksort</em>. No es imprescindible conocerlos todos ni implementarlos ya que las librerías y clases del JDK ya los implementan. Sin embargo, son utilizados como ejemplo para implementar un algoritmo al empezar a programar en un lenguaje de programación.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/06/implementacion-de-los-algoritmos-de-ordenacion-bubble-sort-merge-sort-y-quicksort-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/05/como-ordenar-arrays-y-colecciones-de-objetos-en-java/</id>
        <title>Cómo ordenar arrays y colecciones de objetos en Java</title>
        <updated>2021-05-27T20:00:00+02:00</updated>
        <published>2021-05-27T20:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/05/como-ordenar-arrays-y-colecciones-de-objetos-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Al implementar un algoritmo es común querer iterar los elementos de una colección en un orden según un criterio, por ejemplo, si se trata de números de menor a mayor, si se trata de fechas de menor a mayor y si se trata de personas por orden alfabético del nombre, de menor a mayor edad o de menor a mayor antigüedad en la empresa, también es posible la necesidad de iterar en orden inverso. El JDK de Java proporciona interfaces para implementar la ordenación de objetos y que ya implementan algunos de los algoritmos de ordenación conocidos.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/05/como-ordenar-arrays-y-colecciones-de-objetos-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/05/el-patron-de-diseno-factory-ventajas-sobre-new-y-diferencias-con-builder/</id>
        <title>El patrón de diseño Factory, ventajas sobre new y diferencias con Builder</title>
        <updated>2021-05-14T16:00:00+02:00</updated>
        <published>2021-05-14T16:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/05/el-patron-de-diseno-factory-ventajas-sobre-new-y-diferencias-con-builder/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El patrón de diseño <em>Factory</em> es uno de los patrones dedicados a la creación de instancias. El patrón <em>Factory</em> proporciona varias ventajas sobre la palabra reservada <em>new</em> que proporcionan los lenguajes de programación orientada a objetos para la creación de instancias. Es muy utilizado en muchas librerías, en ocasiones también es necesario implementar una clase que implemente este patrón por lo que es muy útil conocer y usar este patrón en las ocasiones que sea adecuado.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/05/el-patron-de-diseno-factory-ventajas-sobre-new-y-diferencias-con-builder/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/04/crear-de-forma-sencilla-un-cliente-de-un-servicio-rest-o-http-con-retrofit/</id>
        <title>Crear de forma sencilla un cliente de un servicio REST o HTTP con Retrofit</title>
        <updated>2021-04-23T21:30:00+02:00</updated>
        <published>2021-04-23T21:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/04/crear-de-forma-sencilla-un-cliente-de-un-servicio-rest-o-http-con-retrofit/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>La implementación de un servicio REST o HTTP es solo una parte, el otro lado es crear un cliente de ese u otro servicio que permita invocarlo, proporcionar parámetros y obtener las respuestas. Con la librería Retrofit implementar un cliente de un servicio en Java es una tarea bastante sencilla sencilla que utiliza una simple interfaz a la que se le añaden varias anotaciones que le indican a Retrofit cómo construir una implementación a partir de la interfaz. El código que hace uso de la clase que implementa la interfaz del servicio con Retrofit no es diferente de usar una clase que implementa una interfaz.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/04/crear-de-forma-sencilla-un-cliente-de-un-servicio-rest-o-http-con-retrofit/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/04/herramientas-de-reconocimiento-de-texto-en-imagenes-con-ocr/</id>
        <title>Herramientas de reconocimiento de texto en imágenes con OCR</title>
        <updated>2021-04-16T16:30:00+02:00</updated>
        <published>2021-04-16T16:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/04/herramientas-de-reconocimiento-de-texto-en-imagenes-con-ocr/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Un programa de reconocimiento de caracteres o OCR permite obtener el texto de una imagen o fotografía tomada con la cámara de un teléfono inteligente, captura de pantalla, <em>scanner</em> u otro medio. Al programa OCR se le proporciona la imagen y este genera como resultado el texto reconocido, si la imagen es de buena calidad el reconocimiento de caracteres es bastante preciso. Hay programas OCR de línea de comandos, con interfaz gráfica, en línea sin necesidad de instalar software y también es posible realizar OCR desde en un programa con un lenguaje de programación como Java.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/04/herramientas-de-reconocimiento-de-texto-en-imagenes-con-ocr/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/04/las-clases-y-librerias-basicas-de-java-para-bases-de-datos-relacionales/</id>
        <title>Las clases y librerías básicas de Java para bases de datos relacionales</title>
        <updated>2021-04-09T19:00:00+02:00</updated>
        <published>2021-04-09T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/04/las-clases-y-librerias-basicas-de-java-para-bases-de-datos-relacionales/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Las aplicaciones suelen delegar el guardado del estado y de los datos que tratan en sistemas especializados en almacenar datos. Las bases de datos relacionales son sistemas que han probado su eficacia y utilizad durante las últimas décadas de la computación. Aún con la aparición de múltiples bases de datos NoSQL alternativas las bases de datos relacionales se seguirán utilizando o incluso combinando diferentes tipos de bases de datos en un mismo sistema. Java proporciona desde sus primeras versiones el paquete <em>java.sql</em> con varias clases para el acceso a bases de datos relacionales, aunque el acceso a las bases de datos relacionales se suele utilizar a través de librerías es útil conocer estas clases de Java que constituyen los conceptos fundamentales de acceso a base de datos y que las librerías internamente son las que usan.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/04/las-clases-y-librerias-basicas-de-java-para-bases-de-datos-relacionales/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/04/programas-basados-en-consola-con-java-usando-lanterna/</id>
        <title>Programas basados en consola con Java usando Lanterna</title>
        <updated>2021-04-04T00:00:00+02:00</updated>
        <published>2021-04-04T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/04/programas-basados-en-consola-con-java-usando-lanterna/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/04/programas-basados-en-consola-con-java-usando-lanterna/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/03/los-conceptos-de-encapsulacion-herencia-polimorfismo-y-composicion-de-la-programacion-orientada-a-objetos/</id>
        <title>Los conceptos de encapsulación, herencia, polimorfismo y composición de la programación orientada a objetos</title>
        <updated>2021-03-31T19:00:00+02:00</updated>
        <published>2021-03-31T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/03/los-conceptos-de-encapsulacion-herencia-polimorfismo-y-composicion-de-la-programacion-orientada-a-objetos/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>La programación orientada a objetos es un paradigma adoptado por todos lenguajes modernos y publicados en las últimas décadas. La programación orientada a objetos proporciona una sintaxis en el lenguaje para definir abstracciones que hacen sencillo utilizar conceptos cuya implementación es compleja. La encapsulación, la abstracción, la herencia, el polimorfismo, la composición y la inyección de dependencias son conceptos fundamentales a conocer en la programación orientada a objetos.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/03/los-conceptos-de-encapsulacion-herencia-polimorfismo-y-composicion-de-la-programacion-orientada-a-objetos/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/03/novedades-de-java-16/</id>
        <title>Novedades de Java 16</title>
        <updated>2021-03-18T19:00:00+01:00</updated>
        <published>2021-03-18T19:00:00+01:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/03/novedades-de-java-16/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>En Java 16 los cambios en el lenguaje no son tan notables que en versiones anteriores, aún así  el calendario se sigue manteniendo y en cada versión se incluyen mejoras incrementales destacables. Se publica la versión final y lista para producción de algunas características y se añaden nuevas en forma de vista previa.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/03/novedades-de-java-16/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2021/03/repositorio-de-artefactos-privado-con-nexus/</id>
        <title>Repositorio de artefactos privado con Nexus</title>
        <updated>2021-03-12T18:00:00+01:00</updated>
        <published>2021-03-12T18:00:00+01:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2021/03/repositorio-de-artefactos-privado-con-nexus/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Los repositorios de software almacenan los artefactos, son utilizados por las herramientas de construcción que los descargan y almacenan de forma local para posteriores usos las dependencias que los proyectos declaran en el archivo de construcción. Los desarrolladores de los artefactos publican en los repositorios de software las nuevas versiones. Nexus es un repositorio de software con soporte para repositorios de software de varios tipos, Maven para Java, imágenes de Docker, paquetes npm para JavaScript además de artefactos para los lenguajes Python y Go.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2021/03/repositorio-de-artefactos-privado-con-nexus/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
</feed>
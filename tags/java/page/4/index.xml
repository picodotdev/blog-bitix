<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">Blog Bitix</title>
    <subtitle type="text">Blog sobre al lenguaje de programación Java y la distribución GNU/Linux que uso habitualmente, Arch Linux, lo que aprendo sobre el software libre, la programación web y otros temas relacionados con la tecnología y la informática. El contenido puede contener trazas de asuntos fuera de tema.</subtitle>
    <link rel="self" href="https://picodotdev.github.io/blog-bitix/index.xml"/>
    <link href="https://picodotdev.github.io/blog-bitix/" />
    <id>https://picodotdev.github.io/blog-bitix/tags/java/</id>
    <updated>2023-01-11T20:00:00+01:00</updated>
    <author><name>picodotdev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix/assets/favicon.ico</icon>
    <logo>https://picodotdev.github.io/blog-bitix/assets/images/blog-bitix.svg</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/11/crear-un-archivo-zip-con-java-comprimir-y-descomprimir-datos/</id>
        <title>Crear un archivo Zip con Java, comprimir y descomprimir datos</title>
        <updated>2020-11-15T00:30:00+01:00</updated>
        <published>2020-11-15T00:30:00+01:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/11/crear-un-archivo-zip-con-java-comprimir-y-descomprimir-datos/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/11/emitir-trazas-de-las-peticiones-y-respuestas-http-con-clientes-java/</id>
        <title>Emitir trazas de las peticiones y respuestas HTTP con clientes Java</title>
        <updated>2020-11-06T17:00:00+01:00</updated>
        <published>2020-11-06T17:00:00+01:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/11/emitir-trazas-de-las-peticiones-y-respuestas-http-con-clientes-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>En las peticiones HTTP que se hacen unos microservicios a otros o a recursos externos son varias las cosas por las que una petición HTTP es capaz de fallar. El fallo es un código de estado distinto al correcto 200, ya sea petición invalida 400, un recurso no encontrado 404, credenciales requeridas 401, credenciales inválidas 403 o un error interno de servidor 500 entre otros códigos de estado, otras posibilidades son fallos de conexión de red. Añadir trazas de las peticiones que hacen los microservicios permite obtener información con la que averiguar cual es el motivo de fallo, si además emiten las trazas con las cabeceras y parámetros en formato de la herramienta <em>curl</em> es fácil probar y reproducir el mismo error o la misma acción.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/como-depurar-una-aplicacion-java-con-un-ide/</id>
        <title>Cómo depurar una aplicación Java con un IDE</title>
        <updated>2020-10-30T14:30:00+01:00</updated>
        <published>2020-10-30T14:30:00+01:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/como-depurar-una-aplicacion-java-con-un-ide/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>La depuración de un programa o <em>debug</em> permite ejecutar un programa de forma interactiva, paso a paso y examinar los valores de las variables. Esto proporciona valiosa información que permite comprobar el correcto funcionamiento de un programa o descubrir la causa de un error del que las trazas no proporcionan información suficiente. Los depuradores o <em>debuggers</em> son las aplicaciones que ejecutan el programa en modo depuración, permiten establecer puntos de ruptura, continuar la ejecución paso a paso o hasta el siguiente punto de ruptura e inspeccionar los valores de las variables. Los entornos integrados de desarrollo o IDE de Java como IntelliJ IDEA y eclipse ofrecen soporte para hacer depuración.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/entorno-de-desarrollo-java-para-editar-compilar-y-ejecutar-programas/</id>
        <title>Entorno de desarrollo Java para editar, compilar y ejecutar programas</title>
        <updated>2020-10-25T00:00:00+02:00</updated>
        <published>2020-10-25T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/entorno-de-desarrollo-java-para-editar-compilar-y-ejecutar-programas/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>El entorno de desarrollo son la colección de herramientas necesarias para editar código fuente, compilarlo y ejecutar sus programas. El primer paso para aprender a programar en Java es disponer de un entorno de desarrollo con las herramientas mínimas necesarias para practicar y aplicar los conocimientos aprendidos de un curso de formación o utilizando algún libro sobre el lenguaje Java. El entorno mínimo necesario consta del JDK que incluye el compilador Java, otras herramientas que facilitan la programación son un editor avanzado o IDE con asistencia de código y una herramienta de construcción para automatizar tareas.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/como-deduplicar-eventos-de-dominio/</id>
        <title>Cómo deduplicar eventos de dominio</title>
        <updated>2020-10-23T16:00:00+02:00</updated>
        <published>2020-10-23T16:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/como-deduplicar-eventos-de-dominio/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>Las aplicaciones distribuidas utilizan la comunicación de mensajes para notificar de la ocurrencia de ciertos eventos en el sistema que los interesados reciben. En el envío y recepción de mensajes pueden ocurrir dos situaciones que hay que manejar, una es garantizar que cada mensaje se envíe al menos una vez para lo que se emplea el patrón <em>outbox pattern</em> y la segunda es no procesar un evento recibido por duplicado para lo que se emplea deduplicación de mensajes.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/implementar-un-bus-de-comandos-y-consultas-en-java/</id>
        <title>Implementar un bus de comandos y consultas en Java</title>
        <updated>2020-10-16T17:00:00+02:00</updated>
        <published>2020-10-16T17:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/implementar-un-bus-de-comandos-y-consultas-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>Un bus de comandos y consultas permite separar en una aplicación las operaciones de modificación y operaciones de obtención de datos. Esto permite si es requerido dos bases de datos diferentes utilizando CQRS, una base de datos para operaciones de modificación y una base de datos para operaciones de consulta. Aún teniendo solo una base de datos para ambas operaciones un bus de comandos y eventos permite independizar a la aplicación de las interfaces con las que se use ya sea REST, GraphQL, línea de comandos o mensajería como RabbitQM y crear manejadores de operaciones siguiendo los principios SOLID de diseño.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/implementar-un-bus-de-eventos-de-dominio-en-java/</id>
        <title>Implementar un bus de eventos de dominio en Java</title>
        <updated>2020-10-10T18:30:00+02:00</updated>
        <published>2020-10-09T16:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/implementar-un-bus-de-eventos-de-dominio-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>Un bus de eventos es el mecanismo por el que los eventos de dominio de DDD son publicados, son tratados y enviados a sus receptores de forma directa, mediante un <em>middleware</em> u de otra forma. El concepto bus de eventos para eventos de dominio se materializa de forma muy sencilla en código, simplemente una interfaz con un método. Cambiando la implementación de la interfaz un bus de eventos envía los eventos a un sistema de mensajería como RabbitMQ, persiste los eventos en base de datos como parte del <em>outbox pattern</em> o simplemente los imprime en la consola como en el ejemplo del artículo.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/3-formas-de-gestionar-errores-en-los-lenguajes-de-programacion/</id>
        <title>3 formas de gestionar errores en los lenguajes de programación</title>
        <updated>2020-10-04T02:00:00+02:00</updated>
        <published>2020-10-04T02:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/3-formas-de-gestionar-errores-en-los-lenguajes-de-programacion/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>El lenguaje de programación C utiliza códigos de retorno como forma de gestionar errores, Java con excepciones y Go y Rust de forma similar a C códigos de retorno pero con la posibilidad de devolver varios valores, uno para el valor en caso correcto y un valor en caso de error. La gestión de errores es parte esencial de los programas para que funcionen correctamente estando preparados en los casos error posibles.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/10/trazabilidad-en-servicios-distribuidos-con-sleuth-y-zipkin/</id>
        <title>Trazabilidad en servicios distribuidos con Sleuth y Zipkin</title>
        <updated>2020-10-02T17:30:00+02:00</updated>
        <published>2020-10-02T17:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/10/trazabilidad-en-servicios-distribuidos-con-sleuth-y-zipkin/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>En un sistema complejo como una arquitectura de microservicios medir los tiempos de respuesta de cada uno de ellos ayuda a identificar si alguno se está comportando de forma anómala. Sleuth permite asignar un identificador global que es compartido por todos los microservicios invocados en la misma transacción, permite exportar los tiempos de respuesta a Zipkin que ofrece un panel web en el que identificar que llamadas se han hecho entre microservicios y cuales han sido sus tiempos de respuesta.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/09/novedades-de-java-15/</id>
        <title>Novedades de Java 15</title>
        <updated>2020-09-18T14:00:00+02:00</updated>
        <published>2020-09-18T14:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/09/novedades-de-java-15/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>Algunas novedades de anteriores versiones que en la versión de Java 15 pasan a calificarse con el grado de producción y otras características como una segunda versión preliminar. Sin grandes cambios en el lenguaje tan destacables de versiones anteriores como las <em>lambdas</em> de Java 8 o los módulos de Java 9, en Java 15 se añaden las <em>sealed classes</em>.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/08/introduccion-a-grpc-y-ejemplo-con-java/</id>
        <title>Introducción a gRPC y ejemplo con Java</title>
        <updated>2020-08-30T11:30:00+02:00</updated>
        <published>2020-08-30T11:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/08/introduccion-a-grpc-y-ejemplo-con-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>Para crear una API expuesta de forma externa o para ofrecer un servicio a otros servicios en una arquitectura de microservicios ha varias opciones. Tres de las opciones son REST, GraphQL y gRPC cada una con sus características que la hacen mas adecuadas según los requerimientos de la aplicación. gRPC es especialmente adecuada para servicios que requieran un alto rendimiento y solo necesite consumirse de forma interna. gRPC es una implementación de llamada a procedimiento remoto o RPC agnóstica del lenguaje de programación de alto rendimiento al emplear un formato de intercambio de datos binario más eficiente que JSON.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/08/anadir-descripciones-y-documentar-los-campos-de-graphql/</id>
        <title>Añadir descripciones y documentar los campos de GraphQL</title>
        <updated>2020-08-28T00:00:00+02:00</updated>
        <published>2020-08-28T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/08/anadir-descripciones-y-documentar-los-campos-de-graphql/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>A diferencia de una API basada REST una API basada GraphQL posee un esquema en el que quedan definidos los tipos, propiedades y tipos de esas propiedades. Para suplir las carencias de una API basada en REST se suele utilizar #Swagger como documentación y entorno de pruebas. GraphQL incluye la documentación en el propio código fuente y ofrece un IDE sin necesidad de herramientas adicionales. En el propio esquema de la API basada en GraphQL se pueden añadir descripciones a los tipos y propiedades para mayor detalle.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/07/que-son-para-que-sirven-formato-y-ejemplos-de-las-expresiones-cron/</id>
        <title>Qué son, para qué sirven, formato y ejemplos de las expresiones cron</title>
        <updated>2020-07-10T16:15:00+02:00</updated>
        <published>2020-07-10T16:15:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/07/que-son-para-que-sirven-formato-y-ejemplos-de-las-expresiones-cron/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/07/tareas-programadas-de-forma-periodica-con-quartz-y-spring-en-java/</id>
        <title>Tareas programadas de forma periódica con Quartz y Spring en Java</title>
        <updated>2020-07-03T11:30:00+02:00</updated>
        <published>2020-07-03T11:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/07/tareas-programadas-de-forma-periodica-con-quartz-y-spring-en-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2020/06/las-sentencias-de-control-de-flujo-en-java-if-switch-for-while-do-while-try-catch-break-continue-e-invocacion/</id>
        <title>Las sentencias de control de flujo en Java (if, switch, for, while, do-while, try-catch, break, continue e invocación)</title>
        <updated>2020-06-21T07:30:00+02:00</updated>
        <published>2020-06-21T07:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2020/06/las-sentencias-de-control-de-flujo-en-java-if-switch-for-while-do-while-try-catch-break-continue-e-invocacion/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[<p><strong>El lenguaje de programación Java utiliza un paradigma orientado a objetos pero también emplea otros paradigmas como el funcional con la incorporación de las <em>lambas</em> en Java 8 y el imperativo en los bloques de sentencias de los métodos. En este artículo están los tipos de sentencias de control de flujo disponibles en el lenguaje de programación Java: condicionales, de repetición, de asignación, de gestión de excepciones e invocación de métodos en Java.</strong></p>]]>
        
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
</feed>
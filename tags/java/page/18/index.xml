<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">Blog Bitix</title>
    <subtitle type="text">Blog sobre el lenguaje de programación Java y la distribución GNU/Linux que uso habitualmente, Arch Linux, lo que aprendo sobre el software libre, la programación web y otros temas relacionados con la tecnología y la informática. El contenido puede contener trazas de asuntos fuera de tema.</subtitle>
    <link rel="self" href="https://picodotdev.github.io/blog-bitix/index.xml"/>
    <link href="https://picodotdev.github.io/blog-bitix/" />
    <id>https://picodotdev.github.io/blog-bitix/tags/java/</id>
    <updated>2025-09-19T09:00:00+02:00</updated>
    <author></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix/assets/favicon.ico</icon>
    <logo>https://picodotdev.github.io/blog-bitix/assets/images/blog-bitix.svg</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java/</id>
        <title>Múltiples esquemas o bases de datos con jOOQ y Spring en Java</title>
        <updated>2015-11-10T19:00:00+01:00</updated>
        <published>2015-10-27T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Aún en las aplicaciones monolíticas que comparten una única base de datos tratamos de dividirla en varios servicios que manejen cierto nicho de información con la intención de que un cambio en una parte sea transparente para las otras partes. Cada servicio de la aplicación monolítica podría potencialmente convertirse en un microservicio y en este caso para que cada microservicio tenga un ciclo de vida independiente compartir la base de datos es algo a evitar. Incluso en las aplicaciones monolíticas podemos querer guardar cada nicho de información en su propio esquema para evitar acoplamiento entre las diferentes partes o también como forma de tener varios servidores de bases de datos y escalar la aplicación en cierta forma. En estos casos necesitaremos que la aplicación acceda a varios esquemas o bases de datos simultáneamente, con jOOQ y Spring es bastante sencillo.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/multiples-esquemas-o-bases-de-datos-con-jooq-y-spring-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java/</id>
        <title>El patrón de diseño Observer y una forma de implementarlo en Java</title>
        <updated>2015-11-10T19:00:00+01:00</updated>
        <published>2015-10-24T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Otro de los patrones de diseño que en algún momento nos puede ser útil es el patrón <em>Observer</em>. Podemos usar este patrón si tenemos la necesidad de realizar acciones como consecuencia del cambio de estado o cierta circunstancia de un objeto. El patrón <em>Observer</em> nos permite mantener desacoplados el objeto que emite el evento y el objeto que recibe el evento e independizar al objeto observable del número de observadores que tenga.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/el-patron-de-diseno-observer-y-una-forma-de-implementarlo-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/como-crear-clases-factoria-sin-usar-if-else/</id>
        <title>Cómo crear clases factoría sin usar if-else</title>
        <updated>2015-10-19T19:00:00+02:00</updated>
        <published>2015-10-18T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/como-crear-clases-factoria-sin-usar-if-else/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/como-crear-clases-factoria-sin-usar-if-else/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/</id>
        <title>Aplicación Java autocontenida con Spring Boot</title>
        <updated>2015-12-06T12:00:00+01:00</updated>
        <published>2015-10-13T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Si queremos una aplicación Java autocontenida ya sea una aplicación de linea de comandos, de escritorio o aplicación web que use el contenedor de dependencias de Spring podemos usar Spring Boot. Además de inicializar el contenedor IoC de Spring, Spring Boot proporciona en una aplicación web elegir el servidor de aplicaciones de entre el por defecto Tomcat y los seleccionables Jetty y Undertow junto con algunas funcionalidades más.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/aplicacion-java-autocontenida-con-spring-boot/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
                <category term="spring"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml/</id>
        <title>JavaFX Scene Builder, editor para crear archivos FXML</title>
        <updated>2015-11-10T19:00:00+01:00</updated>
        <published>2015-10-09T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Con la aplicación JavaFX Scene Builder podemos construir la interfaz gráfica de una aplicación de escritorio Java de forma más sencilla. JavaFX Scene Builder genera archivos descriptores FXML que podemos cargar en la aplicación evitando la tediosa y no sencilla tarea de construir la interfaz gráfica mediante código. En el artículo comento la aplicación JavaFX Scene Builder, como usar los archivos FXML en una aplicación de escritorio, como asociar manejadores de eventos y como cambiar las propiedades de los controles.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/javafx-scene-builder-editor-para-crear-archivos-fxml/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/similitudes-entre-react-y-polymer-con-apache-tapestry/</id>
        <title>Similitudes entre React y Polymer con Apache Tapestry</title>
        <updated>2015-10-06T18:00:00+02:00</updated>
        <published>2015-10-06T18:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/similitudes-entre-react-y-polymer-con-apache-tapestry/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>React y Polymer son dos librerías JavaScript para construir interfaces complejas en el lado cliente basadas en componentes. Los componentes son interesantes porque hace que el código sea reutilizable, fácil de entender y más fácil de modificar sin introducir errores entre otras cosas. Aunque en el desarrollo web en el lado del servidor la mayoría de los <em>frameworks</em> se basan en acciones también hay algunos que se basan en componentes, uno de ellos Apache Tapestry para la plataforma Java. Si de React y Polymer se está hablando bastante bien y forman parte del actual estado del arte JavaScript, si la gente conociese y usase Tapestry que tiene varias similitudes con ellos creo que también les facilitaría el desarrollo de aplicaciones web pequeñas o grandes, simples o complejas en la parte del servidor.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/similitudes-entre-react-y-polymer-con-apache-tapestry/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="opinion"/>
            
                <category term="planeta-codigo"/>
            
                <category term="tapestry"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/</id>
        <title>Introducción a JavaFX, aplicaciones de escritorio en Java</title>
        <updated>2020-06-04T21:00:00+01:00</updated>
        <published>2015-10-02T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Java tiene una fuerte presencia en el ámbito de desarrollo para aplicaciones web, más recientemente ha sido empleado por la plataforma Android. En la misma medida que han crecido las aplicaciones web y móviles nativas las aplicaciones de escritorio han perdido presencia, sin embargo, para ciertos casos son la opción adecuada. JavaFX es una nueva colección de clases para desarrollar aplicaciones de escritorio multiplataforma «ricas» en la plataforma Java que sustituyen y mejoran las anteriores Swing o AWT. Podemos empezar por el ejemplo Hola Mundo de JavaFX de este artículo.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/10/introduccion-a-javafx-aplicaciones-de-escritorio-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-del-patron-de-diseno-builder/</id>
        <title>Ejemplo del patrón de diseño Builder</title>
        <updated>2015-11-10T19:00:00+01:00</updated>
        <published>2015-09-27T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-del-patron-de-diseno-builder/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Construir objetos es una tarea básica en los lenguajes orientados a objetos. En Java, las instancias de una clase se crean con la palabra clave reservada <em>new</em> y un método especial llamado constructor. Al diseñar una clase debemos tener algunas cuestiones para evitar varios constructores <em>telescópicos</em>, evitar constructores que son combinación de varios argumentos opcionales y permitir obtener instancias de objetos con estado válido. Si se nos presentan estas situaciones podemos usar el patrón de diseño <em>Builder</em> que consiste en básicamente en una clase especializada en construir instancias de otra clase que podemos hacer usable con una API fluida y alguna cosa más deseable que explico en el artículo.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-del-patron-de-diseno-builder/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/09/generar-recursos-estaticos-con-wro4j/</id>
        <title>Generar recursos estáticos con wro4j</title>
        <updated>2015-09-25T17:00:00+02:00</updated>
        <published>2015-09-25T17:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/09/generar-recursos-estaticos-con-wro4j/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Con nuevas tecnologías como less, Sass o CoffeeScript el desarrollo y mantenimiento de una página web medianamente compleja mejora notablemente. Con la librería wro4j en una aplicación Java podemos procesar este tipo de recursos y convertirlos a los equivalentes que saben interpretar los navegadores de forma nativa CSS y JavaScript además de optimizar su tamaño u ofuscarlos.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/09/generar-recursos-estaticos-con-wro4j/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/</id>
        <title>Ejemplo de multiproyecto con Gradle</title>
        <updated>2015-11-10T19:00:00+01:00</updated>
        <published>2015-09-15T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>En un proyecto grande podemos tener necesidad de dividir el monolito al menos en varios módulos y yendo un paso más lejos en microservicios. La herramienta de construcción que usemos deberá de facilitarnos automatizar la tarea de construcción del código fuente de cada módulo individual, de todos a la vez o de los microservicios si tienen alguna dependencia compartida. En el artículo y ejemplo explicaré cómo usando Gradle podemos dividir el proyecto en varios módulos. No deja de ser un ejemplo pero es bastante completo y está formado por dos aplicaciones web, una librería de componentes y otra librería con el modelo de persistencia, usa Spring, jOOQ, Tapestry, PostgreSQL, Docker, Liquibase, &hellip;</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-de-multiproyecto-con-gradle/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
                <category term="tapestry"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-practico-de-serviceloader-con-serviceprovider-de-java-money/</id>
        <title>Ejemplo práctico de ServiceLoader con ServiceProvider de Java Money</title>
        <updated>2015-09-13T11:00:00+02:00</updated>
        <published>2015-09-13T11:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-practico-de-serviceloader-con-serviceprovider-de-java-money/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Una aplicación que trabaje con importes y diferentes divisas necesitará ratios de conversión, estos ratios de conversión deberemos obtenerlos de algún servicio. Con la API de Java Money que aun en Java 8 no está incorporada en el JDK aunque si como una librería podremos trabajar de forma cómoda con importes, divisas y ratios. En este artículo explicaré un ejemplo de uso práctico de la clase ServiceLoader y como obtener ratios del servicio Open Exchange Rates.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/09/ejemplo-practico-de-serviceloader-con-serviceprovider-de-java-money/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader/</id>
        <title>Aplicación Java extensible con la clase ServiceLoader</title>
        <updated>2015-09-12T10:00:00+02:00</updated>
        <published>2015-09-12T10:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Java ofrece un mecanismo incluido en el propio JDK para hacer las aplicaciones extensibles o ampliables en un momento posterior al de desarrollo. La clase <em>ServiceLoader</em> permite obtener las implementaciones definidas en el <em>classpath</em> de una determinada interfaz. En este artículo explico esta clase y muestro un ejemplo sencillo de como usarla.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/09/aplicacion-java-extensible-con-la-clase-serviceloader/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/08/implementacion-de-maquina-de-estados-finita-fsm-con-java-8/</id>
        <title>Implementación de máquina de estados finita (FSM) con Java 8</title>
        <updated>2016-02-25T21:00:00+01:00</updated>
        <published>2015-08-01T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/08/implementacion-de-maquina-de-estados-finita-fsm-con-java-8/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Es raro pero no he encontrado una librería adecuada en Java con una implementación de una máquina de estados. Stateless4j puede ser una candidata pero también tiene algunas deficiencias que pueden hacer que no nos sirva. Basándome en Stateless4j y usando Java 8 he creado una implementación de FSM con una funcionalidad similar y más ligera donde una única instancia de la máquina de estados es independiente del número de instancias de objetos en las que se use.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/08/implementacion-de-maquina-de-estados-finita-fsm-con-java-8/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/07/como-trabajar-con-importes-ratios-y-divisas-en-java/</id>
        <title>Cómo trabajar con importes, ratios y divisas en Java</title>
        <updated>2015-07-21T20:30:00+02:00</updated>
        <published>2015-07-21T20:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/07/como-trabajar-con-importes-ratios-y-divisas-en-java/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Aún en Java 8 no tenemos una API incluida en el JDK dedicada al manejo de importes, divisas y conversiones. Si la especificación JSR-354 se incluye en alguna versión podremos hacer uso de ella sin necesidad de ninguna dependencia adicional, pero si tenemos necesidad ahora podemos usar la librería que ha producido la especificación. Usando las clases y métodos de la API evitaremos hacer y mantener una implementación nosotros mismos que además seguro no llega al nivel de esta.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/07/como-trabajar-con-importes-ratios-y-divisas-en-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2015/06/hemeroteca-7/</id>
        <title>Hemeroteca #7</title>
        <updated>2015-06-27T22:00:00+02:00</updated>
        <published>2015-06-27T10:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2015/06/hemeroteca-7/"/>
        <author><name></name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Pasado un nuevo semestre he escrito principalmente sobre temas de programación, Java y poco sobre Linux o software libre. Incluyo aquí el listado completo de los artículos que he escrito.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2015/06/hemeroteca-7/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="blog"/>
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
                <category term="software"/>
            
                <category term="software-libre"/>
            
                <category term="tapestry"/>
            
                <category term="gnu-linux"/>
            
        
    </entry>
    
</feed>
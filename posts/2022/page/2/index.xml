<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title type="text">Blog Bitix</title>
    <subtitle type="text">Blog sobre al lenguaje de programación Java y la distribución GNU/Linux que uso habitualmente, Arch Linux, lo que aprendo sobre el software libre, la programación web y otros temas relacionados con la tecnología y la informática. El contenido puede contener trazas de asuntos fuera de tema.</subtitle>
    <link rel="self" href="https://picodotdev.github.io/blog-bitix/index.xml"/>
    <link href="https://picodotdev.github.io/blog-bitix/" />
    <id>https://picodotdev.github.io/blog-bitix/posts/2022/</id>
    <updated>2022-12-29T21:00:00+01:00</updated>
    <author><name>picodotdev</name></author>
    <generator>Hugo</generator>
    <icon>https://picodotdev.github.io/blog-bitix/assets/favicon.ico</icon>
    <logo>https://picodotdev.github.io/blog-bitix/assets/images/blog-bitix.svg</logo>
    <rights>https://creativecommons.org/licenses/by-sa/4.0/</rights>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/09/como-refrescar-el-access-token-de-un-cliente-oauth-cuando-caduca/</id>
        <title>Cómo refrescar el access token de un cliente OAuth cuando caduca</title>
        <updated>2022-09-15T21:00:00+02:00</updated>
        <published>2022-09-15T21:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/09/como-refrescar-el-access-token-de-un-cliente-oauth-cuando-caduca/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Dado que el protocolo HTTP es un protocolo sin estado los <em>access token</em> se envían en cada petición que se hace al <em>endpoint</em> de un recurso ofrecido por una aplicación mediante una interfaz REST. Para limitar el periodo de que un <em>access tokens</em> sea utilizable en caso de ser filtrado estos se crean con un tiempo de vida corto, los clientes para seguir realizando peticiones han de solicitar al servidor de autorización un nuevo <em>access token</em>. La librería OkHttp permite realizar la renovación de forma transparente para el cliente y en el código donde se usa.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/09/como-refrescar-el-access-token-de-un-cliente-oauth-cuando-caduca/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/09/introduccion-al-protocolo-oauth-2-para-delegar-la-autorizacion/</id>
        <title>Introducción al protocolo OAuth 2 para delegar la autorización</title>
        <updated>2022-09-08T11:00:00+02:00</updated>
        <published>2022-09-08T11:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/09/introduccion-al-protocolo-oauth-2-para-delegar-la-autorizacion/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El protocolo OAuth es un protocolo en el ámbito de la seguridad que permite que el dueño de los recursos conceda permisos a un cliente sin necesidad de compartir las credenciales, el servidor de recursos unicamente necesita un <em>token</em> que certifique el cliente tiene permisos para acceder a los recursos, el <em>token</em> es emitido por el servidor de autorización en el que el usuario se autentica y en el que servidor de recursos confía en los <em>tokens</em> de autorización que emite. Gracias a la flexibilidad del protocolo OAuth y estar basado en la ubicuidad del protocolo HTTP este es el mecanismo de autorización adoptado predominantemente en la web por los diferentes servicios que ofrecen sus APIs mediante REST sin limitarse a este tipo de APIs. OAuth se compone de varias especificaciones que permiten delegar la autorización, OpenID Connect construido sobre OAuth proporciona otro aspecto de la seguridad, la autenticación.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/09/introduccion-al-protocolo-oauth-2-para-delegar-la-autorizacion/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-de-la-aventura-galactica-ratchet-y-clank/</id>
        <title>Análisis del juego de la aventura galáctica Ratchet &amp; Clank</title>
        <updated>2022-08-31T19:00:00+02:00</updated>
        <published>2022-08-31T19:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-de-la-aventura-galactica-ratchet-y-clank/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El juego Ratchet &amp; Clank es un juego icónico de las consolas PlayStation, la versión para la PS4 es un buen juego que entretiene con una historia sencilla de los típicos villanos junto a unos muy buenos gráficos. Un juego para todos los públicos que quizá a parte del público más adulto no sea un juego que les emocione tanto como otros juegos de la generación de la PS4.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-de-la-aventura-galactica-ratchet-y-clank/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="juegos"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/08/desempaquetado-y-analisis-de-la-interfaz-de-audio-maonocaster-e2/</id>
        <title>Desempaquetado y análisis de la interfaz de audio Maonocaster E2</title>
        <updated>2022-08-23T12:00:00+02:00</updated>
        <published>2022-08-23T12:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/08/desempaquetado-y-analisis-de-la-interfaz-de-audio-maonocaster-e2/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Para grabar contenido de audio un micrófono es esencial para un audio de calidad, una interfaz de audio no es imprescindible pero si muy recomendable. Las interfaces de audio son un dispositivo hardware capaz de realizar varias funciones. Entre las ventajas de una interfaz de audio están que proporciona un gran número de conexiones que una computadora no suele tener, mezcla el audio de varias fuentes, permite aplicar algunos efectos básicos pero muy útiles y permite realizar grabaciones sin necesidad de un ordenador. En este artículo realizo el desempaquetado y análisis de la interfaz de audio Maonocaster E2 que tiene un conjunto de características y funciones que cubren las necesidades de la mayoría de usuarios que realizan grabaciones por afición, algunos con resultados casi profesionales en el contenido que crean, e incluso es capaz e cubrir las necesidades a nivel profesional, todo con un precio económico para lo que proporciona.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/08/desempaquetado-y-analisis-de-la-interfaz-de-audio-maonocaster-e2/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="hardware"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/08/prueba-de-velocidad-de-unidad-de-almacenamiento-en-gnu-linux/</id>
        <title>Prueba de velocidad de unidad de almacenamiento en GNU/Linux</title>
        <updated>2022-08-18T18:00:00+02:00</updated>
        <published>2022-08-18T18:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/08/prueba-de-velocidad-de-unidad-de-almacenamiento-en-gnu-linux/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>En un dispositivo de almacenamiento hay que tener en cuenta el tipo de la interfaz del dispositivo que determina la tasa de transferencia máxima teórica, el tipo de almacenamiento que determina en qué rangos de tasa de transferencia ofrecen la mayoría de dispositivos, el dispositivo en concreto que dependiendo del fabricante y calidad determina en qué parte del rango está la tasa de transferencia el modelo usado, la capacidad de almacenamiento y finalmente el precio que está en función de todo lo anterior.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/08/prueba-de-velocidad-de-unidad-de-almacenamiento-en-gnu-linux/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="hardware"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/08/ejemplo-de-patron-builder-para-las-clases-record-de-java/</id>
        <title>Ejemplo de patrón Builder para las clases Record de Java</title>
        <updated>2022-08-12T18:30:00+02:00</updated>
        <published>2022-08-12T18:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/08/ejemplo-de-patron-builder-para-las-clases-record-de-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Java se ha caracterizado por ser un lenguaje verboso y necesitar declarar todo de forma explícita, esto tiene la ventaja de que el código es muy explícito sin apenas convenciones que es necesario conocer para saber cómo se comporta el código. Por el contrario esta verbosidad requiere declarar gran cantidad de código que se hace repetitivo en muchas clases. Los <em>Records</em> de Java 16 permite declarar clases de datos en muy pocas líneas de código, esto lo consiguen introduciendo algunas convenciones que son de uso común en el lenguaje. Un aspecto que no resuelven los <em>Records</em> es el crear clases Builder que son una necesidad asociada para esas clases de datos.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/08/ejemplo-de-patron-builder-para-las-clases-record-de-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-con-combates-epicos-god-of-war/</id>
        <title>Análisis del juego con combates épicos God of War</title>
        <updated>2022-08-04T20:00:00+02:00</updated>
        <published>2022-08-04T20:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-con-combates-epicos-god-of-war/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Haber llegado tarde a la generación de PS4 hace que tenga disponible la totalidad del catálogo de PS4. Estoy jugando a muchos de los mejores juegos de la PS4 y del God of War me esperaba un buen juego pero me ha sorprendido por ser mucho mejor de lo que pensaba en historia, mundo y mitología, combates, habilidades, diálogos, puzzles, coleccionables, &hellip; Muy completo.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/08/analisis-del-juego-con-combates-epicos-god-of-war/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="juegos"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/07/opciones-de-arquitectura-para-emitir-trazas-en-una-aplicacion-java/</id>
        <title>Opciones de arquitectura para emitir trazas en una aplicación Java</title>
        <updated>2022-07-28T19:30:00+02:00</updated>
        <published>2022-07-28T19:30:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/07/opciones-de-arquitectura-para-emitir-trazas-en-una-aplicacion-java/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Incluso para emitir trazas que en principio es algo sencillo y que se da por hecho surgen varias opciones de arquitectura o diseño. Dos de esas decisiones son acoplarse o no a la librería de <em>logging</em> que se use e inyectar de forma estática o por el constructor la instancia de la clase con la que se emiten trazas. Estas decisiones conviene recogerlas en un documento de <em>Architecture Decision Record</em> por si en un futuro hay que revisar las decisiones tomadas con anterioridad o para que una persona en un futuro tenga el contexto y un registro de las decisiones que se han tomado, el contexto, opciones evaluadas, argumentos y decisiones tomadas.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/07/opciones-de-arquitectura-para-emitir-trazas-en-una-aplicacion-java/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
                <category term="programacion"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/07/desempaquetado-y-analisis-del-microfono-maono-hd300t/</id>
        <title>Desempaquetado y análisis del micrófono MAONO HD300T</title>
        <updated>2022-07-24T02:00:00+02:00</updated>
        <published>2022-07-24T02:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/07/desempaquetado-y-analisis-del-microfono-maono-hd300t/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El MAONO HD300T es un micrófono dinámico cardioide muy polivalente gracias a sus múltiples conexiones tanto USB, XLR como <em>jack</em> 3.5mm que incluye además en su contenido cables, una peana con soporte antigolpes y un filtro <em>pop</em>. Ofrece el conjunto completo básico para la captura de audio ya sea vocal o instrumental con fin de crear contenido en video blogs, un canal de YouTube, realizar <em>streaming</em> de juegos, contenido en tiempo real o para ser usado en programas de videoconferencia. Un micrófono más que suficiente para un ámbito de usuario, una calidad de audio muy superior a un micrófono interno de un portátil y muy completo con precio muy atractivo que hace de él una adquisición recomendable.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/07/desempaquetado-y-analisis-del-microfono-maono-hd300t/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="hardware"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/07/interfaz-web-para-jmx-con-hawtio/</id>
        <title>Interfaz web para JMX con Hawtio</title>
        <updated>2022-07-14T00:00:00+02:00</updated>
        <published>2022-07-14T00:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/07/interfaz-web-para-jmx-con-hawtio/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Una cosa es la funcionalidad que proporciona una aplicación y otra las tareas de administración y mantenimiento relacionas con la aplicación. Estas tareas de administración y mantenimiento no son tareas destinadas a los usuarios sino destinadas a los administradores de la aplicación. Estas tareas pueden ser manuales y ejecutadas a conveniencia siendo muy útil poder ejecutarlas sin necesidad de realizar cambios en el código ni un despliegue de la aplicación. La tecnología JMX de Java define una arquitectura para administrar y monitorizar aplicaciones que se puede utilizar para estas tareas administrativas, Hawtio es una interfaz que permite el acceso y ejecución a JMX mediante un navegador y proporciona una librería para integrase con Spring Boot.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/07/interfaz-web-para-jmx-con-hawtio/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/07/generar-releases-de-un-proyecto-java-con-gradle/</id>
        <title>Generar releases de un proyecto Java con Gradle</title>
        <updated>2022-07-08T16:00:00+02:00</updated>
        <published>2022-07-08T16:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/07/generar-releases-de-un-proyecto-java-con-gradle/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>Utilizar las etiquetas de las herramientas de control de versiones permite conservar ciertos hitos o <em>commits</em> importantes para consultarlos en el futuro. Generar una versión de un proyecto suele implicar generar una etiqueta en la herramienta de control de versiones. Dado que la generación de nuevas versiones es parte del ciclo de vida de un proyecto hay <em>plugins</em> tanto para Maven como para Gradle que ofrecen como funcionalidad automatizar esta proceso.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/07/generar-releases-de-un-proyecto-java-con-gradle/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="java"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/06/hemeroteca-21/</id>
        <title>Hemeroteca #21</title>
        <updated>2022-06-30T23:00:00+02:00</updated>
        <published>2022-06-30T23:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/06/hemeroteca-21/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>En el resumen de este semestre en Blog Bitix está el haber colaborado con una marca de teclados mecánicos con varios artículos promocionados la primera de este tipo en el blog. He añadido la plataforma publicitaria que hasta el momento va a suponer los ingresos del blog. En cuanto a alis un nuevo diseño para su página web y unos pocos cambios con mejoras en el script. Por la parte de artículos del blog he estado publicado habitualmente un único artículo en vez de dos como en otras épocas pasadas, unos 25 artículos únicos y originales más y van ya más de 600.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/06/hemeroteca-21/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="blog"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/06/personalizar-el-simbolo-del-sistema-de-la-linea-de-comandos-con-starship/</id>
        <title>Personalizar el símbolo del sistema de la línea de comandos con Starship</title>
        <updated>2022-06-26T04:00:00+02:00</updated>
        <published>2022-06-26T04:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/06/personalizar-el-simbolo-del-sistema-de-la-linea-de-comandos-con-starship/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El símbolo del sistema o <em>prompt</em> en la línea de comandos de la terminal precede a la introducción del comando a ejecutar. Los intérpretes de comandos o <em>shells</em> ofrecen un símbolo del sistema por defecto que muestran cierta información y con el formato que sus desarrolladores han elegido. Además de que cada intérprete de comandos tenga uno propio estos son bastante limitados en cuanto a personalización además de utilizar una configuración poco intuitiva. Starship es un personalizador del símbolo del sistema independiente del intérprete de comandos, que ofrece una gran cantidad de módulos para personalizar el símbolo del sistema según el directorio de trabajo actual y cuya configuración es muy intuitiva y está bien documentada.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/06/personalizar-el-simbolo-del-sistema-de-la-linea-de-comandos-con-starship/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/06/los-interpretes-de-comandos-instalar-y-cambiar-a-otro/</id>
        <title>Los intérpretes de comandos, instalar y cambiar a otro</title>
        <updated>2022-06-23T21:00:00+02:00</updated>
        <published>2022-06-23T21:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/06/los-interpretes-de-comandos-instalar-y-cambiar-a-otro/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>La terminal es una herramienta muy utilizada por usuarios avanzados aún habiendo sistemas operativos en los que prácticamente todo se puede realizar desde un programa con interfaz gráfica. La linea de comandos es menos amigable ya que no ofrece apenas ayuda que guíe al usuario pero cuando un usuario conoce como realizar una tarea desde la línea de comandos es mucho más rápido que usar un programa con interfaz gráfica además de otras ventajas. El intérprete de comandos es la pieza que proporciona un entorno dese el que se introducen los comandos y con el que interacciona el usuario desde la terminal con una interfaz basada en texto.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/06/los-interpretes-de-comandos-instalar-y-cambiar-a-otro/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="gnu-linux"/>
            
                <category term="planeta-codigo"/>
            
        
    </entry>
    <entry>
        <id>https://picodotdev.github.io/blog-bitix/2022/06/desempaquetado-y-analisis-del-teclado-mecanico-compacto-e-inalambrico-kemove-ares/</id>
        <title>Desempaquetado y análisis del teclado mecánico compacto e inalámbrico KEMOVE ARES</title>
        <updated>2022-06-16T18:00:00+02:00</updated>
        <published>2022-06-16T18:00:00+02:00</published>
        <link rel="alternate" type="text/html" href="https://picodotdev.github.io/blog-bitix/2022/06/desempaquetado-y-analisis-del-teclado-mecanico-compacto-e-inalambrico-kemove-ares/"/>
        <author><name>picodotdev</name></author>
        <content type="html">
        <![CDATA[

        <p><strong>El teclado mecánico KEMOVE ARES está en la gama alta de teclados para los usuarios que desean lo mejor sin tener en cuenta tanto el precio. Compacto en formato 60%, inalámbrico, RGB, <em>keycaps</em> con disposición ANSI y serigrafía de la disposición en inglés. Siendo similar en muchos aspectos al KEMOVE DK61 el ARES tiene un cuerpo de metal y mejores materiales de construcción que se notan en los <em>keycaps</em>, estabilidad de las teclas y en el sonido de tecleo. Al ser de metal aluminio ofrece mayor durabilidad, por otro lado por su diseño lo hace único y está disponible en varios colores, tipos y marcas de <em>switches</em>.</strong></p>
        
        <p><a href="https://picodotdev.github.io/blog-bitix/2022/06/desempaquetado-y-analisis-del-teclado-mecanico-compacto-e-inalambrico-kemove-ares/">Continuar leyendo en Blog Bitix</a></p>

        ]]>
        </content>
        
            
                <category term="hardware"/>
            
        
    </entry>
    
</feed>